# -*- coding: utf-8 -*-
"""lstm_regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/177at6jNikjuogHdRSr6vrsIM160E3SHF
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow import keras
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import LSTM, Dense, Dropout
from keras.layers import *
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error
from keras.callbacks import EarlyStopping
from numpy import *
from pandas import *
from sklearn.metrics import *
from math import sqrt

from google.colab import drive
drive.mount('/content/drive')

#if you want to predict variables for Up reserve energy set energy_type='Up'
#if you want to predict variables for Down reserve energy set energy_type='Down'
energy_type='Up'

#if you want to predict the quantity set var_type=0
#if you want to predict the price set var_type=1
var_type=0

if energy_type==True:
  df= pd.read_excel('/content/drive/MyDrive/BE/BE_names.xlsx')
else:
  df= pd.read_excel('/content/drive/MyDrive/BE/Actual_Units_Down.xlsx')

Date['Day'] = pd.to_datetime(Date['Day'])
Date = Date.set_index('Day')
Date = Date.loc['2021-02-13':'2021-07-14']

date1 = Date.loc[:, 'SinWeekDay':'CosHour']

entityname=df.names.values


for i in entityname:
  print(i)
  vars()[i] = pd.read_excel('/content/drive/MyDrive/BE/BE_'+str(energy_type)+'_New_New/%s.xlsx' % i)
  vars()[i] = vars()[i].set_index('Date')
  vars()[i] = vars()[i].fillna(0)

def quantity_values(entity, max_steps):
  quantity = entity.loc[:, 'Step1Quantity':'Step'+str(max_steps)+'Quantity']
  for i in range(1, max_steps+1):
    
    column_values = quantity['Step'+str(i)+'Quantity'].values
    stepval = 'Step'+str(i)+'Val'
    vars()[stepval] =  np.unique(column_values)
    vars()[stepval] = pd.DataFrame(vars()[stepval])
    if i ==1:
      val = vars()[stepval].copy()
    else:
      val = pd.concat([val, vars()[stepval]], axis=1)
  
  val= val.fillna(0)
  return val

def classification2(value, x, max_list, max_quantity, min_step):
  clas = np.zeros(len(x))
  
  d = pd.DataFrame(index=np.arange(len(x)), columns=np.arange(3))
  #print(clas, d)
  p = max_quantity[0]
  for j in range(0, len(x)):
    dif = []
    for i in range(0, len(value)):
      dif.append(abs(x[j]-value.iat[i,j]))
    d.iat[j,0] = min(dif)
    d.iat[j,1] = j
    d.iat[j,2] = value.iat[dif.index(min(dif)), j]
  p -= d.iat[j,2]
  if len(x)>1:
    d = d.sort_values(by= [0], axis=0)
  if min_step>0:
    k = 0
    while p>0:
      
      if k<len(x):
        clas[int(d.iat[k,1])] = d.iat[k,2]
        p-= d.iat[k,2]
      
      if p<0:
        clas[int(d.iat[k,1])] += p 
      k+=1
      if p>0 and k == len(x)-1:
        clas[int(d.iat[k,1])] +=p
        p=0
      
  
  clas = np.array(clas)
  #print(d)
  #print(step)
  return clas

def classification(value, x, max_quantity):
  if x<0:
    clas = 0
  elif x>max_quantity:
    clas = max_quantity
  else:
    d = []
    for i in range(len(value)):
      d.append(abs(x-value.iat[i]))
    min = d[0]
    clas = value[0]
    for j in range(1, len(d)):
      if d[j]<min:
        min = d[j]
        clas = value.iat[j]
  return float(clas)

def classification3(value, x, max_quantity):
  if x<0:
    clas = 0
  else:
    clas = x
  return float(clas)

def accuracy_score_manual(pred, real):
  k=0
  for i in range(0, len(pred)):
    if pred.iat[i] == real.iat[i]:
      k+=1
  return k*100/len(pred)

def split_sequences(data, lookback, lookforward, final_step):
	X, y = list(), list()
	for i in range(len(data)-lookback):
		end_ix = i + lookback
		out_end_ix = end_ix + lookforward
		if out_end_ix > len(data):
			break
		seq_x, seq_y = data[i:end_ix, 0:data.shape[1]], data[end_ix:out_end_ix, 0:final_step]
		X.append(seq_x)
		y.append(seq_y)
	return np.array(X), np.array(y)



scl = MinMaxScaler()

column_name = []
for k in range(0, 336):
  column_name.append('predicted')
  column_name.append('classified')
  column_name.append('real')

error_index=[]
for i in entityname:
  error_index.append(''+str(i)+'')
  error_index.append('')
error_index.append('mean real')
error_index.append('mean clas')

error_name = []
error_name.append('Type of pred')
for k in range(1,11):
  error_name.append('MAE')
  error_name.append('RMSE')

g=0
tot_error = pd.DataFrame(index=np.arange(len(error_index)), columns=np.arange(22))
for p in range(0, int(len(tot_error)/2)):
  tot_error.iat[2*p,0] = 'orig'
  tot_error.iat[2*p+1,0] = 'class'
tot_pred = 0
weeks_of_pred = 7
pred_type = 0
if var_type=0:
  col_num = 0 #col num=0 for quantity and clo_num=10 for prices
  diagram_names = 'Quantity'
  save_names = 'Quantity'
else:
  col_num = 10 #col num=0 for quantity and clo_num=10 for prices
  diagram_names = 'Price'
  save_names = 'Price'


for i in entityname:
  entity = vars()[i].loc[:, :]
  entity = entity.loc['2021-02-13':'2021-07-14']
  variable= entity.loc[:, 'VariableCost']
  availability = entity.loc[:, 'Availability']
  
  min_step = min(entity.NumOfSteps)
  final_step = max(entity.NumOfSteps)
  entity1 = entity.iloc[:, col_num+3:final_step+col_num+3]
  max_list = entity1.max(axis=0).values
  min_list = entity1.min(axis=0).values
  max_quantity = entity1.iloc[0:1, :].sum(axis=1)
  max_quantity = max_quantity.values
  #print(min_step)
  dataset1 = entity1
  
  #dataset1 = pd.concat([entity1, date1, variable, availability], axis=1)
  #dataset1 = pd.concat([entity1, variable, availability, date], axis=1)
  #dataset1 = dataset1.replace(np.nan, 0)
  #prepare the dataset and transform 
  #print(dataset1)
  if final_step>0:
    tot_pred +=1
    cl = dataset1.values.reshape(dataset1.shape[0],len(dataset1.columns))
    cl
    cl = scl.fit_transform(cl)
    lookback =7*48
    lookforward = 7*48
    X,y = split_sequences(cl, lookback, lookforward, final_step)
    #split the data by multyply of 48 
    for k in range(1, X.shape[0], 7*48):
      if abs(X.shape[0]*0.8-k) < abs(X.shape[0]*0.8-(k-1)):
        split = k-1
    X_train,X_test = X[:split], X[split:X.shape[0]]
    y_train,y_test = y[:split],y[split:y.shape[0]]
    X_test_model = X_test[0:len(X_test)-336, :, :]
    X_test_pre = X_test[len(X_test)-336:, :, :]
    y_test_model = y_test[0:len(y_test)-336, :, :]
    y_test_pre = y_test[len(y_test)-336:, :, :]

    #create the model
    model = Sequential()
    model.add(LSTM(100, input_shape=(X_train.shape[1], X_train.shape[2]),return_sequences=True))
    model.add(Dropout(0.05))
    #model.add(LSTM(80, return_sequences = True))
    #model.add(Dropout(0.05))
    #model.add(LSTM(80, return_sequences = True))
    model.add(Dense(units=48, ))# activation='relu'
    model.add(Dense(units=final_step, ))#activation='linear'
    adam = keras.optimizers.Adam(learning_rate=0.001)
    model.compile(optimizer=adam, loss='mae')


    print(model.summary())
    X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], X_train.shape[2])
    X_test_pre = X_test_pre.reshape(X_test_pre.shape[0], X_test_pre.shape[1], X_test_pre.shape[2])
    X_test_model = X_test_model.reshape(X_test_model.shape[0], X_test_model.shape[1], X_test_model.shape[2])



    history = model.fit(X_train,y_train,epochs=100,validation_data=(X_test_model, y_test_model), 
                        batch_size=64,callbacks=[EarlyStopping(monitor='loss', patience=10)], shuffle=False)
    

    Xt = model.predict(X_test_pre)
    prediction = Xt.copy()
    real_val = y_test_pre.copy()
  
    #reverse transform
    for z in range(0,Xt.shape[0]):
      for j in range(0,Xt.shape[1]):
        for k in range(0, Xt.shape[2]):
          prediction[z,j,k] = prediction[z,j,k]*(max_list[k]-min_list[k])+min_list[k]
          real_val[z,j,k] = real_val[z,j,k]*(max_list[k]-min_list[k])+min_list[k]

    #classify the predicted value with the closest value which unit usualy bid
    prediction1 = prediction.copy()
    value = quantity_values(entity, final_step)
    
    #if len(value)<7:
      #for z in range(0, prediction.shape[0]):
        #for j in range(0, prediction.shape[1]):
          #prediction1[z,j,:] = classification(value, prediction[z,j,:],  max_list, max_quantity, min_step) 
           
    #a = pd.DataFrame(index=np.arange(prediction.shape[0]), columns=np.arange(final_step*2+2))
    #a = a.drop([0], axis=1)
    name=[]
    
    for j in range(0, final_step):
      name.append('Step'+str(j+1)+'Predicted')
      name.append('Step'+str(j+1)+'Classified')
      name.append('Step'+str(j+1)+'Real')
    name.append('NumOfSTeps_pred')
    name.append('NumOfSTeps_clas')
    name.append('NumOfSteps_real')
    mae_col_name = []
    mae_col_name.append('Date')
    mae_col_name.append('')
    for j in range(1, final_step+1):
      mae_col_name.append('MAE')
      mae_col_name.append('RMSE')
    mae_col_name.append('Accuracy')

    #get only the prediction that made at 12pm
    index_list = []
    mae = pd.DataFrame(index=np.arange(2*weeks_of_pred+2), columns=np.arange(2*final_step+3))
    real = entity['Step1'+str(diagram_names)+'']
    for t in range(0, 7):
      a = pd.DataFrame(index=np.arange(prediction.shape[0]+1), columns=np.arange(final_step*3+3))
      #a = a.drop([0], axis=1)


      for k in range(0, prediction.shape[2]):
        row=0
        
        for r in range(48*t+48-1, prediction.shape[0],336):
          for j in range(0, prediction.shape[1]):
            a.iat[row,3*k]= prediction[r,j,k]
            if var_type=0:
              a.iat[row,3*k+1]= classification(value.iloc[:,k],prediction1[r,j,k], max_quantity)
            else:
              a.iat[row,3*k+1]= classification3(value.iloc[:,k],prediction1[r,j,k], max_quantity)
          
            a.iat[row,3*k+2] = real_val[r,j,k]
            row+=1




      for k in range(0, len(a)):
        pr=0
        cp=0
        rv = 0
        for j in range(0, final_step):
          if a.iat[k,3*j]>0:
            pr += 1
          if a.iat[k, 3*j+1]>0:
            cp +=1
          if a.iat[k,3*j+2]>0:
            rv += 1
        a.iat[k,3*final_step] = pr
        a.iat[k, 3*final_step+1] = cp
        a.iat[k, 3*final_step+2] = rv

      a = a.drop(a.index[len(a)-1]) 

      a.columns = name
      d = entity.iloc[(len(entity)-336-(6-t)*48):(len(entity)-(6-t)*48), :]
      a.index = d.index
      a.to_excel('/content/drive/MyDrive/BE/BE_'+str(energy_type)+'_New/LSTM/lastweekpredwithdates2/'+str(save_names)+'/predictions/'+str(i)+ ' prediction at '+str(t)+'day.xlsx')
      col = 1
      fig = plt
      a['Step1Real'].plot(figsize=(30,18), fontsize=30)
      a['Step1Predicted'].plot(figsize=(30,18), fontsize=30)
      a['Step1Classified'].plot(figsize=(30,18), fontsize=30)
      plt.title(''+str(i)+'  Step1 '+str(diagram_names)+'', fontsize=30)
      plt.xlabel("Date", fontsize=30)
      plt.ylabel(''+str(diagram_names)+'', fontsize=30)
      plt.xticks(fontsize=30)
      plt.yticks(fontsize=30)
      plt.legend(prop={'size':30})
      #plt.show()
      fig.savefig('/content/drive/MyDrive/BE/BE_'+str(energy_type)+'_New/LSTM/lastweekpredwithdates2/'+str(save_names)+'/diagram/'+str(i)+ ' prediction at '+str(t)+'day.png')
      if t==6:
        fig.savefig('/content/drive/MyDrive/BE/BE_'+str(energy_type)+'_New/LSTM/lastweekpredwithdates2/'+str(save_names)+'/diagram_final/'+str(i)+ '.png')
      plt.close()
      
      index_list = a.index.tolist()
      first_day = index_list[0].day
      first_day_month = index_list[0].month
      last_day = index_list[len(index_list)-1].day
      last_day_month = index_list[len(index_list)-1].month
      date = '{}/{}-{}/{}'.format(first_day, first_day_month, last_day, last_day_month)
      mae.iat[2*t,0] = date
      mae.iat[2*t+1,0] = ''
      for p in range(0, 7):
        mae.iat[2*p, 1] = 'Orig'
        mae.iat[2*p+1, 1] = 'Class'
      
      for k in range(0, final_step): 
        mae.iat[2*t, 2*k+2] = mean_absolute_error(a.iloc[:, 3*k+2], a.iloc[:, 3*k])
        mae.iat[2*t, 2*k+3] = sqrt(mean_squared_error(a.iloc[:, 3*k+2], a.iloc[:, 3*k]))
        mae.iat[2*t+1, 2*k+2] = mean_absolute_error(a.iloc[:, 3*k+2], a.iloc[:, 3*k+1])
        mae.iat[2*t+1, 2*k+3] = sqrt(mean_squared_error(a.iloc[:, 3*k+2], a.iloc[:, 3*k+1]))

    
    mae.iat[2*weeks_of_pred,0] = 'mean real error'
    mae.iat[2*weeks_of_pred+1,0] = 'mean clas error'
    mae.columns = mae_col_name
    mae =  mae.set_index('Date')


    
    for k in range(1, len(mae.columns)):
      sum1=0
      sum2=0

      for p in range(0, weeks_of_pred):
     
        sum1 += mae.iat[2*p,k]
        sum2 = sum2 + mae.iat[2*p+1,k]
        
      mae.iat[2*weeks_of_pred, k] = sum1/(weeks_of_pred)
      mae.iat[2*weeks_of_pred+1, k] = sum2/(weeks_of_pred)

      if k ==len(mae.columns)-1:
        tot_error.iat[g, 21] = mae.iat[2*weeks_of_pred, k]
        tot_error.iat[g+1, 21] = mae.iat[2*weeks_of_pred+1, k]
      else:
        tot_error.iat[g, k] = mae.iat[2*weeks_of_pred, k]
        tot_error.iat[g+1, k] = mae.iat[2*weeks_of_pred+1, k]
    mae.to_excel('/content/drive/MyDrive/BE/BE_'+str(energy_type)+'_New/LSTM/lastweekpredwithdates2/'+str(save_names)+'/error/'+str(i)+'.xlsx')
    #calculate the mae for each day of prediction
    

    
    #diagram
    
    
    #save every prediction for every 30min
    table_class=[]
    for z in range(0, prediction.shape[0]):
      for j in range(0, prediction.shape[1]):
        table_class.append(prediction[z,j,0])
        table_class.append(prediction1[z,j,0])
        table_class.append(real_val[z,j,0])
    table_class = np.array(table_class)
    table_class = table_class.reshape(int(len(table_class)/1008), 1008)
    

    table_class = pd.DataFrame(table_class)
    table_class.columns = column_name
    #table_class.to_excel('/content/drive/MyDrive/BE/BE_Down_New/LSTM/lastweekpredwithdates/prediction_step1full/'+str(i)+'.xlsx')
    print (g, i)
    g = g+2

tot_error = tot_error.fillna(0)
for j in range(1, len(tot_error.columns)):

  sum1 =0
  sum2 = 0
  for p in range(0, int(len(tot_error)/2)-1):
    sum1 += tot_error.iat[2*p, j]
    sum2 += tot_error.iat[2*p+1, j]
    
  tot_error.iat[len(tot_error)-2, j] = sum1/tot_pred
  tot_error.iat[len(tot_error)-1, j] = sum2/tot_pred



tot_error.columns = error_name
tot_error.index = error_index
tot_error.to_excel('/content/drive/MyDrive/BE/BE_'+str(energy_type)+'_New/LSTM/lastweekpredwithdates2/'+str(save_names)+'/mean_error.xlsx')

